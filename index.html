<!DOCTYPE html>
<html>
  <head>
    <title>Cryptographic Event Log v0.1</title>
    <meta http-equiv='Content-Type' content='text/html;charset=utf-8'/>
    <!--
      === NOTA BENE ===
      For the three scripts below, if your spec resides on dev.w3 you can check them
      out in the same tree and use relative links so that they'll work offline,
     -->
    <script src='https://www.w3.org/Tools/respec/respec-w3c' class='remove'></script>
    <script class="remove"
      src="https://cdn.jsdelivr.net/gh/digitalbazaar/respec-vc@3.3.5/dist/main.js"></script>

    <script class="remove">
      var respecConfig = {
        group: "credentials",

        // specification status (for example, WD, LCWD, NOTE, etc.). If in doubt use ED.
        specStatus: "CG-DRAFT",

        // the specification's short name, as in http://www.w3.org/TR/short-name/
        shortName: "cel-1.0",

        // subtitle for the spec
        subtitle: "A cryptographic protocol for verifying a log of changes to data",

        // if you wish the publication date to be other than today, set this
        //publishDate: "2024-11-05",
        //crEnd: "2024-12-05",
        //prEnd: "2019-10-01",
        //implementationReportURI: "https://w3c.github.io/vc-data-model-2.0-test-suite/",
        //errata: "https://w3c.github.io/vc-data-model/errata.html",
        //previousMaturity: "REC",
        //previousPublishDate: "2022-03-03",

        // if there is a previously published draft, uncomment this and set its YYYY-MM-DD date
        // and its maturity status
        // previousPublishDate:  "1977-03-15",
        // previousMaturity:  "WD",

        // extend the bibliography entries
        localBiblio: {},
        doJsonLd: true,

        // Uncomment these to use the respec extension that generates a list of
        //   normative statements:
        preProcess: [/*prepare_reqlist*/],
        postProcess: [
          /*add_reqlist_button*/
        ],

        github: "https://github.com/digitalbazaar/cel-spec/",
        includePermalinks: false,

        // if there a publicly available Editor's Draft, this is the link
        edDraftURI: "https://digitalbazaar.github.io/cel-spec/",

        // if this is a LCWD, uncomment and set the end of its review period
        // lcEnd: "2009-08-05",

        // editors, add as many as you like
        // only "name" is required
        editors: [
          { name: "Manu Sporny", url: "https://www.linkedin.com/in/manusporny/",
            company: "Digital Bazaar", companyURL: "https://digitalbazaar.com/",
            w3cid: 41758}
        ],
        formerEditors: [
        ],
        // authors, add as many as you like.
        // This is optional, uncomment if you have authors as well as editors.
        // only "name" is required. Same format as editors.
        authors:
        [
          { name: "Manu Sporny", url: "https://digitalbazaar.com/",
            company: "Digital Bazaar", companyURL: "https://digitalbazaar.com/",
            w3cid: 41758
          },
          { name: "Dave Longley", url: "https://digitalbazaar.com/",
            company: "Digital Bazaar", companyURL: "https://digitalbazaar.com/",
            w3cid: 48025
          },
          { name: "Christine Lemmer-Webber",
            url: "https://dustycloud.org/",
            company: "Spritely Institute",
            companyURL: "https://spritely.institute/",
            w3cid: 0
          }
        ],
        xref: ["URL", "I18N-GLOSSARY", "INFRA", "VC-DATA-INTEGRITY"],
        lint: { "informative-dfn": false },
        maxTocLevel: 3,
        inlineCSS: true
      };
    </script>
    <style>
code {
  color: rgb(199, 73, 0);
  font-weight: bold;
}
pre {
  overflow-x: auto;
  white-space: pre-wrap;
}
pre .highlight {
  font-weight: bold;
  color: Green;
}
pre .subject {
  font-weight: bold;
  color: RoyalBlue;
}
pre .property {
  font-weight: bold;
  color: DarkGoldenrod;
}
pre .comment {
  font-weight: bold;
  color: SteelBlue;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}
ol.algorithm {
  counter-reset: numsection;
  list-style-type: none;
}
ol.algorithm li {
  margin: 0.5em 0;
}
ol.algorithm li:before {
  font-weight: bold;
  counter-increment: numsection;
  content: counters(numsection, ".") ") ";
}

table.simple {
    border-collapse: collapse;
    margin: 25px 0;
    min-width: 400px;
    border: 1px solid #dddddd;
}
table.simple thead tr {
    background-color: #005a9c;
    color: #ffffff;
    text-align: left;
}
table.simple th,
table.simple td {
    padding: 12px 15px;
    vertical-align: top;
    text-align: left;
}
table.simple tbody tr {
    border-bottom: 1px solid #dddddd;
}
table.simple tbody tr:nth-of-type(even) {
    background-color: #00000008;
}
table.simple tbody tr:last-of-type {
    border-bottom: 2px solid #005a9c;
}
    </style>
  </head>
  <body>
    <section id='abstract'>
      <p>
This specification defines a data model for an author to express changes to data
over time and the means for a verifier to cryptographically verify those
changes.
      </p>
    </section>

    <section id='sotd'>
      <p>
An experimental thought exercise, for now. Potentially, a data structure for
cryptographic event logging of data objects such as DID Documents, ActivityPub
objects, and other data formats.
      </p>
    </section>

    <section class="informative">
      <h2>Introduction</h2>

      <p>
In decentralized systems, coordination relies on a shared view of reality to
make decisions. This shared reality can include various types of information,
such as the balance of a financial account, the current holder of cryptographic
material (like a public key), the location of a physical asset, or the sequence
of comments in an online forum. When this information is expressed digitally, it
is important to understand the order of events that led to the current state.
Additionally, it is crucial for systems to be able to share this information in
a decentralized way, with guarantees that the event log has not been tampered
with over time.
      </p>

      <p>
One approach to securing a cryptographic log of information is to establish a
cryptographic key to be associated with a particular piece of data and then only
trust changes to that information where each change is digitally signed by the
controller of the cryptographic key. One challenge with this approach is that
the controller might modify the sequence of events at any point, effectively
rewriting history, if they can gain an advantage in a decentralized system.
      </p>

      <p>
To prevent rewriting history, some decentralized systems have turned to
centralized solutions to "witness" the log of events that change the underlying
data. Centralized solutions tend to create problems with the power dynamics
in an ecosystem and, unsurprisingly, centralized previously decentralized solutions.
      </p>

      <p>
Other decentralized systems have turned to solutions such as decentralized
ledger technologies (also known as blockchains) to share the state of a system.
Some of these decentralized solutions tend to create their own problems such as
energy use that some view as excessive (proof of work) or an excessive
centralization of capital (proof of stake). Decentralized solutions
also tend to make some governments nervous and slow adoption due to the
uncertainty associated with the political dynamic of the underlying
cryptocurrency.
      </p>

      <p>
This specification defines a decentralized cryptographic event log format
where a verifier depends on the controller of a particular piece of data,
as well as external witnesses that they trust, to establish trust in the
current state of a particular object in a decentralized system.
      </p>

      <section id="conformance">
        <p>
A <dfn>conforming log</dfn> is any [=byte sequence=] that can be
converted to a
<a data-cite="INFRA#parse-json-bytes-to-a-javascript-value">
JSON document</a> that follows the relevant normative requirements in
Sections [[[#data-model]]].
        </p>

        <p>
A <dfn class="lint-ignore">conforming extension specification</dfn> is
any specification that follows the relevant normative requirements in Section
[[[#extension-specifications]]].
        </p>

        <p>
A <dfn class="lint-ignore">conforming processor</dfn> is any algorithm realized
as software and/or hardware that generates and/or consumes a
[=conforming log=] according to the relevant normative statements
in Section [[[#algorithms]]]. Conforming processors MUST produce errors when
non-conforming documents are consumed.
        </p>
      </section>

    </section>

    <section class="normative">
      <h2>Data Model</h2>

      <p>
A <dfn data-lt="event log">cryptographic event log</dfn> is a [=list=] of
protected events that enable an author to express changes to a specific instance
of data over time in a way that is tamper tamper-evident and that can be
cryptographically verified by verifiers in a decentralized manner.
      </p>

      <section class="normative">
        <h2>Event Entry</h2>

        <p>
A cryptographic <dfn data-lt="event entry">event log entry</dfn> is used to
establish an event that can be independently verified by a verifier. The log
entry MUST be composed of at least a single `event` and one or more associated
`proof` values that can be used to verify the validity of the event. The `event`
value is defined below  and MUST include either a `data` entry or a
`dataReference` entry:
        </p>

        <table class="simple">
          <thead>
            <tr>
              <th style="white-space: nowrap">Property</th>
              <th>Description</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>type</td>
              <td>
A REQUIRED property whose value is the type of event being expressed. A
[=conforming processor=] MUST support the following [=string=] values: `Create`,
`Update`, and `Deactivate` and MAY support other values defined by
[=conforming extension specifications=].
              </td>
            </tr>
            <tr>
              <td>data</td>
              <td>
An OPTIONAL property whose value contains the JSON expression of the data
being secured. If this property is specified, the `dataReference` property
MUST NOT be specified.
              </td>
            </tr>
            <tr>
              <td>dataReference</td>
              <td>
An OPTIONAL property whose value contains a reference and cryptographic hash
to the data being secured. If this property is specified, the `data` property
MUST NOT be specified. The format for the value is defined below:

                <table class="simple">
                  <thead>
                    <tr>
                      <th style="white-space: nowrap">Property</th>
                      <th>Description</th>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td>url</td>
                      <td>
An OPTIONAL property whose value MUST be a [=list=] of one or more URLs that
can be used to retrieve the data being secured. If no `url` value is specified,
the mechanism used to retrieve the data is application-specific.
                      </td>
                    </tr>
                    <tr>
                      <td>mediaType</td>
                      <td>
An OPTIONAL property whose value MUST be a media type as defined by
[[[RFC6838]]].
                      </td>
                    </tr>
                    <tr>
                      <td>digestMultibase</td>
                      <td>
A REQUIRED property whose value MUST be a <a
data-cite="CONTROLLER-DOCUMENT#multibase-0">Multibase-encoded</a> (base64-url-nopad) <a
data-cite="CONTROLLER-DOCUMENT#multihash">Multihash</a> (sha2-256) value.
                      </td>
                    </tr>
                  </tbody>
                </table>
              </td>
            </tr>
          </tbody>
        </table>

        <p>
A [=conforming processor=] MUST support `proof` values expressed using the
[[[VC-DI-ECDSA]]] specification and the `ecdsa-jcs-2019` cryptosuite and
MAY support other proof formats.
        </p>

        <pre class="example nohighlight" title="An event log entry containing data embedded directly in the event.">
{
  "event": {
    <span class="comment">// the type of event</span>
    "type": "Create",
    <span class="comment">// the data associated with the event (in JSON format)</span>
    "data": {
      "name": "Hello World!",
      <span class="comment">// the cryptographic authority for the data is established in this object</span>
      <span class="comment">// for example: "authority": "https://website.example/crypto#key-1"</span>
    }
  },
  <span class="comment">// one or more proofs that secure the integrity of the event above</span>
  "proof": {
    "type": "DataIntegrityProof",
    "cryptosuite": "ecdsa-jcs-2019",
    "created": "2024-11-29T13:56:28Z",
    "verificationMethod": "https://website.example/crypto#key-1",
    "proofPurpose": "assertionMethod",
    "proofValue": "zq6PrUMCtqY5obCSsrQxuFJd...wVWgHYrXxoV93gBHqGDBtQLPFxpZxz"
  }
}
        </pre>

        <p>
Some data are too large to include in the event log itself. For these cases,
it is possible to refer to data outside of the event log and digitally sign
a cryptographic hash of the external data. It is also possible to provide
multiple URLs for a verifier to use when retrieving the external data.
        </p>

        <pre class="example nohighlight" title="An event log entry containing a reference to data.">
{
  "event": {
    "type": "Create",
    <span class="comment">// a reference to the data associated with the event</span>
    "dataReference": {
      <span class="comment">// URLs that can be used to retrieve the data</span>
      "url": [
        "https://website.example/file.dat",
        "3jxop4cs2lu5ur2...sseqdsp3k262uwy4.onion/file.dat",
        "ipfs://QmTy8w65yBXgyfG2ZBg5TrfB2hPjrDQH3RCQFJGkARStJb"
      ],
      <span class="comment">// The media type of the associated data</span>
      "mediaType": "application/octet-stream",
      <span class="comment">// a cryptographic digest of the data (sha2-256 base64-url-nopad)</span>
      "digestMultibase": "uEiAkoYyQ6YVtUmER8pN24wLZcLK9EBguM5WZlbAgfXBDuQ"
    }
  },
  <span class="comment">// one or more proofs that secure the integrity of the event above</span>
  "proof": {
    "type": "DataIntegrityProof",
    "cryptosuite": "ecdsa-jcs-2019",
    "created": "2024-11-29T13:56:28Z",
    "verificationMethod": "https://website.example/crypto#key-1",
    "proofPurpose": "assertionMethod",
    "proofValue": "z5obCSsrQxuFJdq6PrUMCtqY...93gBHqGDBtQLPFxpZxzwVWgHYrXxoV"
  }
}
        </pre>


      </section>

      <section class="normative">
        <h2>Event Witness</h2>

        <p>
An <dfn>event witness</dfn> is a service that can attest to the existence of
data at a particular point in time. These services are trusted by the verifier
to attest to the existence of data at a particular point in time by digitally
signing a cryptographic hash that is provided to them such that they do not
see the data, but confirm the existence of the data.
        </p>

        <p>
The [=event witness=] performs their function by appending another
[=data integrity proof=] onto the array of `proof` values.
        </p>

        <pre class="example nohighlight" title="An event log entry containing a reference to data.">
{
  "event": {
    "type": "Create",
    <span class="comment">// a reference to the data associated with the event</span>
    "dataReference": {
      <span class="comment">// URLs that can be used to retrieve the data</span>
      "url": [
        "https://website.example/file.dat",
        "3jxop4cs2lu5ur2...sseqdsp3k262uwy4.onion/file.dat",
        "ipfs://QmTy8w65yBXgyfG2ZBg5TrfB2hPjrDQH3RCQFJGkARStJb"
      ],
      <span class="comment">// The media type of the associated data</span>
      "mediaType": "application/octet-stream",
      <span class="comment">// a cryptographic digest of the data (sha2-256 base64-url-nopad)</span>
      "digestMultibase": "uEiAkoYyQ6YVtUmER8pN24wLZcLK9EBguM5WZlbAgfXBDuQ"
    }
  },
  <span class="comment">// one or more proofs that secure the integrity of the event above</span>
  "proof": [{
    "type": "DataIntegrityProof",
    "cryptosuite": "ecdsa-jcs-2019",
    "created": "2024-11-29T13:56:28Z",
    "verificationMethod": "https://website.example/crypto#key-1",
    "proofPurpose": "assertionMethod",
    "proofValue": "z5obCSsrQxuFJdq6PrUMCtqY...93gBHqGDBtQLPFxpZxzwVWgHYrXxoV"
  }, {
    "type": "DataIntegrityProof",
    "cryptosuite": "ecdsa-jcs-2019",
    "created": "2024-11-29T13:56:45Z",
    "verificationMethod": "https://witness.example/attestation#key-P8",
    "proofPurpose": "assertionMethod",
    "proofValue": "zJdq6PrUMCtqY5obCSsrQxuF...tQLPFxpZxzwVWgHYrXxoV93gBHqGDB"
  }]
}
        </pre>

      </section>

    </section>

    <section class="normative">
      <h2>Serializations</h2>

      <p>
The data model described in this specification can be serialized as JSON or
CBOR.
      </p>

      <p class="issue" title="Multiple serializations increase complexity">
If we do not provide a CBOR serialization, some subset of the developer
community will complain. The only argument for a CBOR serialization is
ensuring a byte-optimized storage format. We could make CBOR the default
serialization, but at the cost of alienating developers that don't work in
CBOR (which is most of them). The only time size restrictions come into
play is with large event logs (or large binaries in event logs), which are a
possibility. We're going to start out with JSON, see how far it gets us, and
see if the pro-CBOR community would be willing to trade CPU cycles to
convert to/from CBOR from JSON (ensuring a stable round-tripping). The number
of fields we'd have to pick CBOR values for is minimal.
      </p>

      <section class="normative">
        <h3>JSON</h3>

      <p class="issue" title="Default representation is JSON">
The default representation for a [=cryptographic event log=] is JSON. That
might change if we get enough developer feedback to use CBOR.
      </p>

      </section>

      <section class="normative">
        <h3>CBOR</h3>

      <p class="issue" title="Default representation is JSON">
The default representation for a [=cryptographic event log=] is JSON. That
might change if we get enough developer feedback to use CBOR. The alternative
is to provide a bi-directional mapping to CBOR which reduces storage
requirements.
      </p>
      </section>

    </section>

    <section class="normative">
      <h2>Algorithms</h2>

      <p>
The algorithms described in this section outline the procedures used to ensure
the integrity and security of the event log. These algorithms provide the means
for securely recording, verifying, and sharing changes to data in a
decentralized system. By leveraging cryptographic techniques, the algorithms
ensure that the event log is tamper-proof and verifiable, allowing parties to
independently confirm the authenticity of the data. The following subsections
detail the specific algorithms used for creating event entries, verifying their
integrity, and ensuring consistency across systems.
      </p>

      <section class="normative">
        <h2>Create Event Log</h2>

        <p>
The following algorithm defines the process for creating an event log.
        </p>

        <ol class="algorithm">
          <li>
Let |eventLog| be an empty [=list=].
          </li>
          <li>
Let |event| be the output of Section [[[#create-event]]].
          </li>
          <li>
Append |event| to |eventLog|.
          </li>
          <li>
Return |eventLog|.
          </li>
        </ol>

      </section>

      <section class="normative">
        <h2>Create Event</h2>

        <p>
The following algorithm defines the process for creating an event log entry.
The event log serves as a record of changes to data within a system, capturing
key information such as the type of event, the associated cryptographic hash of
the protected data, and a proof that secures both. The algorithm ensures that
each event is securely logged and that the integrity of the data is maintained
over time. By following this process, systems can reliably document and share
events, providing verifiable evidence of changes while maintaining
decentralization and security.
        </p>

        <p>
Required inputs are an [=event log=] ([=map=] inputEventLog), and
[=event entry=] ([=map=] |inputEvent|) and a set of
options ([=map=] |options|). An [=event log=] ([=map=]), or an error,
is produced as output.
        </p>

        <ol class="algorithm">
          <li>
Let |event| be a deep copy of |inputEvent| and let |eventLog| be a deep copy of
|inputEventLog|.
          </li>
          <li>
Ensure that |event|.|type| is set to `Create` or throw an error.
          </li>
          <li>
Let |event|.|proof| be the output of |options|.|createProof| algorithm if it is
specified, or the <a data-cite="VC-DI-ECDSA##create-proof-ecdsa-jcs-2019">
ECDSA Create Proof Algorithm (ecdsa-jcs-2019)</a> with |event| and
|options|.|proofOptions| passed in as |unsecuredDataDocument| and |options|,
respectively.
          </li>
          <li>
Append |event| to |eventLog|.
          </li>
          <li>
Return |eventLog|.
          </li>
        </ol>

      </section>

      <section class="normative">
        <h2>Witness Event</h2>

        <p>
The following algorithm defines the process for witnessing an event log entry.
A witness for an event log entry does so by digitally signing a cryptographic
hash instead of viewing the data directly. This provides privacy for the
author and eliminates liability for the witness. Effectively, the signed
value states: "I witness cryptographic has X at point in time Y.", which
establishes that the data existed at that particular point in time. Witness
services are expected to be external to the system requesting the witnessing,
such as through an HTTP endpoint that accepts a cryptographic hash as input.
        </p>

        <p class="issue" title="Define HTTP endpoint function call">
This specification should probably define the witness HTTP endpoint function
call. The endpoint would take in a `digestMultibase` value and produce a
valid [=data integrity proof=].
        </p>

        <p>
Required inputs are an [=event entry=] ([=map=] |inputEvent|) and a set of
options ([=map=] |options|). An [=event entry=] ([=map=]), or an error,
is produced as output.
        </p>

        <ol class="algorithm">
          <li>
Let |event| be a deep copy of |inputEvent|.
          </li>
          <li>
Ensure that |event|.|proof| exists, and is a [=list=].
          </li>
          <li>
Let |eventHash| be the result of cryptographically hashing |event| using the
rules defined for `digestMultibase` in Section [[[#event-entry]]].
          </li>
          <li>
Let |witnessProof| be the output of calling a witness service to generate
a digital signature according to the |options|.|cryptosuite| algorithm if it is
specified, or the <a data-cite="VC-DI-ECDSA##create-proof-ecdsa-jcs-2019">
ECDSA Create Proof Algorithm (ecdsa-jcs-2019)</a> with |eventHash| as input.
          </li>
          <li>
Append |witnessProof| to |event|.|proof|.
          </li>
          <li>
Return |event|.
          </li>
        </ol>

      </section>

      <section class="normative">
        <h2>Update Event Log</h2>

        <p>
This section outlines the algorithm for updating an existing event log entry. As
events occur and data changes, it is essential to ensure that the event log
remains accurate, up-to-date, and secure. The update process involves appending
new event entries while preserving the integrity of previous entries through
cryptographic validation. This algorithm ensures that each update is properly
recorded and can be verified independently, allowing systems to maintain an
up-to-date, tamper-proof record of all changes.
        </p>

        <ol class="algorithm">
          <li>
Let |event| be a deep copy of |inputEvent| and let |eventLog| be a deep copy of
|inputEventLog|.
          </li>
          <li>
Ensure that |event|.|type| is set to `Update` or throw an error.
          </li>
          <li>
Let |event|.|proof| be the output of |options|.|createProof| algorithm if it is
specified, or the <a data-cite="VC-DI-ECDSA##create-proof-ecdsa-jcs-2019">
ECDSA Create Proof Algorithm (ecdsa-jcs-2019)</a> with |event| and
|options|.|proofOptions| passed in as |unsecuredDataDocument| and |options|,
respectively.
          </li>
          <li>
Append |event| to |eventLog|.
          </li>
          <li>
Return |eventLog|.
          </li>
        </ol>

      </section>

      <section class="normative">
        <h2>Deactivate Event Log</h2>

        <p>
This section describes the algorithm for deactivating an event log entry when it
is no longer relevant or needed. Deactivation marks the point at which an event
log is no longer active, ensuring that no further changes can be made to the
entry while maintaining the integrity of the data already recorded. The
algorithm ensures that the deactivation process is secure, verifiable, and
irreversible, allowing systems to formally close out event logs without
compromising the authenticity of prior entries.
        </p>

        <ol class="algorithm">
          <li>
Let |event| be a deep copy of |inputEvent| and let |eventLog| be a deep copy of
|inputEventLog|.
          </li>
          <li>
Ensure that |event|.|type| is set to `Deactivate` or throw an error.
          </li>
          <li>
Let |event|.|proof| be the output of |options|.|createProof| algorithm if it is
specified, or the <a data-cite="VC-DI-ECDSA##create-proof-ecdsa-jcs-2019">
ECDSA Create Proof Algorithm (ecdsa-jcs-2019)</a> with |event| and
|options|.|proofOptions| passed in as |unsecuredDataDocument| and |options|,
respectively.
          </li>
          <li>
Append |event| to |eventLog|.
          </li>
          <li>
Return |eventLog|.
          </li>
        </ol>

      </section>

      <section class="normative">
        <h2>Verify Event Log</h2>

        <p>
This section outlines the algorithm for verifying the integrity and authenticity
of an event log. The process ensures that the event log has not been tampered
with and that each entry is consistent with the expected cryptographic proofs.
By using cryptographic signatures and validation techniques, the algorithm
allows verifiers to independently confirm that the recorded events are genuine
and have not been altered over time. This verification process is essential for
maintaining trust and accountability in decentralized systems, where
participants rely on accurate records that have not been tampered with over
time.
        </p>

        <ol class="algorithm">
          <li>
Let |eventLog| be a deep copy of |inputEventLog|.
          </li>
          <li>
For each |event| in |eventLog|, for each |proof| in |event|:
            <ol class="algorithm">
              <li>
Verify |proof| using the |options|.|verifyProof| algorithm if it is
specified, or the <a data-cite="VC-DI-ECDSA#verify-proof-ecdsa-jcs-2019">
ECDSA Verify Proof Algorithm (ecdsa-jcs-2019)</a> with |event| and
|options|.|proofOptions| passed in as |securedDataDocument| and |options|,
respectively.
              </li>
              <li>
If the proof verification fails, raise an error.
              </li>
            </ol>
          </li>
          <li>
Return |true|.
          </li>
        </ol>

      </section>

    </section>

    <section class="normative">
      <h2>Extension Specifications</h2>

      <p>

      </p>

    </section>

  </body>
</html>
